/*eslint-env node, mocha*/
/**
 * Generated by PluginGenerator 2.20.5 from webgme on Thu Sep 05 2019 16:23:11 GMT-0500 (Central Daylight Time).
 */

describe('ImportKeras', function () {
    var testFixture = require('../../globals'),
        BlobClient = require('webgme-engine/src/server/middleware/blob/BlobClientWithFSBackend'),
        fs = require('fs'),
        Q = testFixture.Q,
        {promisify} = require('util'),
        assert = require('assert'),
        gmeConfig = testFixture.getGmeConfig(),
        expect = testFixture.expect,
        path = testFixture.path,
        logger = testFixture.logger.fork('ImportKeras'),
        PluginCliManager = testFixture.WebGME.PluginCliManager,
        SEED_DIR = path.join(__dirname, '..', '..', '..', 'src', 'seeds'),
        manager = new PluginCliManager(null, logger, gmeConfig),
        projectName = 'testProject',
        pluginName = 'ImportKeras',
        blobClient = new BlobClient(gmeConfig, logger),
        JSON_DIR = path.join(__dirname, '../../test-cases/modelJsons/'),
        project,
        gmeAuth,
        awaitableLoadObject,
        storage,
        commitHash,
        plugin;

    before(function (done) {
        testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName)
            .then(function (gmeAuth_) {
                gmeAuth = gmeAuth_;
                // This uses in memory storage. Use testFixture.getMongoStorage to persist test to database.
                storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);
                return storage.openDatabase();
            })
            .then(function () {
                var importParam = {
                    projectSeed: path.join(SEED_DIR, 'keras', 'keras.webgmex'),
                    projectName: projectName,
                    branchName: 'master',
                    logger: logger,
                    gmeConfig: gmeConfig
                };

                return testFixture.importProject(storage, importParam);
            })
            .then(function (importResult) {
                project = importResult.project;
                commitHash = importResult.commitHash;
                awaitableLoadObject = promisify(project.loadObject);
                return project.createBranch('test', commitHash);
            })
            .then(() => manager.initializePlugin(pluginName))
            .then(plugin_ => {
                let context = {
                    project: project,
                    commitHash: commitHash,
                    branchName: 'test',
                    activeNode: testFixture.LANGUAGE.languageRelID
                };
                plugin = plugin_;
                return manager.configurePlugin(plugin, {}, context);
            })
            .nodeify(done);
    });

    after(function (done) {
        logger.info('database closing');
        storage.closeDatabase()
            .then(function () {
                return gmeAuth.unload();
            })
            .nodeify(done);
    });

    describe('without-json-setup', function () {
        it('should fail without providing the JSON file', function (done) {
            let pluginConfig = {},
                context = {
                    project: project,
                    commitHash: commitHash,
                    branchName: 'test',
                    activeNode: testFixture.LANGUAGE.languageRelID
                };
            manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {

                try {
                    expect(err.message).to.equal('Keras Json Not Provided');
                    expect(pluginResult.success).to.equal(false);
                } catch (e) {
                    done(e);
                    return;
                }
                // Because it fails, nothing is commited
                project.getBranchHash('test')
                    .then(function (branchHash) {
                        expect(branchHash).to.equal(commitHash);
                    })
                    .nodeify(done);
            });
        });
    });

    const runPluginTest = async (modelName) => {
         let manager = new PluginCliManager(null, logger, gmeConfig),
             runPlugin = promisify(manager.executePlugin),
             pluginConfig = {},
            context = {
                project: project,
                activeNode: '',
                branchName: 'test'
            };

         let data = fs.readFileSync(path.join(JSON_DIR, modelName), 'utf-8');

         assert(data != null);

         let branchHash = await project.getBranchHash('test');
         let commitObject = await awaitableLoadObject(branchHash);
         let rootNode = await plugin.core.loadRoot(commitObject.root);

         assert(rootNode != null);

         let childrenPaths = (await plugin.core.loadChildren(rootNode)).map(plugin.core.getPath);
         pluginConfig.srcModel = await blobClient.putFile(modelName, data);
         let pluginResult = await runPlugin(pluginName, pluginConfig, context);

         assert(pluginResult != null);
         assert(pluginResult.success === true);
         assert(rootNode != null);

         let newBranchHash = await project.getBranchHash('test');
         commitHash = newBranchHash;
         let newCommitObj = await awaitableLoadObject(newBranchHash);

         let newRootNode = await plugin.core.loadRoot(newCommitObj.root);
         let newChildrenPaths = (await plugin.core.loadChildren(newRootNode)).map(plugin.core.getPath);
         assert(newChildrenPaths.length === childrenPaths.length + 1);
    };


    describe('test-cases', function () {
        let modelsToTest = fs.readdirSync(JSON_DIR).filter((targetFile) => { return targetFile.endsWith('.json')});

        modelsToTest.forEach((model) => {
            it(`should run plugin for ${model}`, async () => {
                await runPluginTest(model);
            });
        });
    });


});
