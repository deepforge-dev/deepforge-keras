/**
 * Generated by PluginGenerator 2.16.0 from webgme on Thu May 03 2018 17:13:15 GMT-0500 (CDT).
 */

'use strict';
const testFixture = require('../../globals');
const pluginName = 'ValidateKeras';

describe(pluginName, function () {
    const Q = require('q');
    const gmeConfig = testFixture.getGmeConfig();
    const expect = testFixture.expect;
    const assert = require('assert');
    const BlobClient = require('webgme-engine/src/server/middleware/blob/BlobClientWithFSBackend');
    const logger = testFixture.logger.fork(pluginName);
    const blobClient = new BlobClient(gmeConfig, logger);
    const PluginCliManager = testFixture.WebGME.PluginCliManager;
    const projectName = 'testProject';
    const manager = new PluginCliManager(null, logger, gmeConfig);
    const ARCHITECTURE = testFixture.ARCHITECTURE;

    let project,
        gmeAuth,
        storage,
        commitHash;

    before(function (done) {
        testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName)
            .then(function (gmeAuth_) {
                gmeAuth = gmeAuth_;
                // This uses in memory storage. Use testFixture.getMongoStorage to persist test to database.
                storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);
                return storage.openDatabase();
            })
            .then(function () {
                var importParam = {
                    projectSeed: testFixture.testSeedPath,
                    projectName: projectName,
                    branchName: 'master',
                    logger: logger,
                    gmeConfig: gmeConfig
                };

                return testFixture.importProject(storage, importParam);
            })
            .then(function (importResult) {
                project = importResult.project;
                commitHash = importResult.commitHash;
                return project.createBranch('test', commitHash);
            })
            .then(() => {
                return manager.initializePlugin(pluginName);
            })
            .nodeify(done);
    });

    after(function (done) {
        storage.closeDatabase()
            .then(function () {
                return gmeAuth.unload();
            })
            .nodeify(done);
    });

    function getGeneratedCode(nodeId) {
        let pluginConfig = {
            },
            context = {
                project: project,
                commitHash: commitHash,
                branchName: 'test',
                activeNode: nodeId,
                namespace: 'keras'
            };

        return Q.ninvoke(manager, 'executePlugin', pluginName, pluginConfig, context)
            .then(pluginResult => {
                expect(typeof pluginResult).to.equal('object');
                expect(pluginResult.success).to.equal(true);
                let codeHash = pluginResult.artifacts[0];
                return blobClient.getObject(codeHash)
                    .then(obj => String.fromCharCode.apply(null, new Uint8Array(obj)));
            });
    }

    describe('code', function() {
        let code;
        before(function(done) {  // run the plugin and get the generated code
            getGeneratedCode(ARCHITECTURE.Basic)
                .then(result => code = result)
                .nodeify(done);
        });

        it('should import all keras layers', function() {
            assert(code.includes('from keras.layers import *'));
        });

        it('should create a model', function() {
            assert(code.includes('model = Model('));
        });

        it('should import Model', function() {
            assert(code.includes('import Model'));
        });

        it('should resolve activation pointers', function() {
            assert(!code.includes('[object Object]'));
        });

        it('should name custom fns by parameters', function() {
            const lines = code.split('\n');
            const custom_relu = lines
                .find(line => line.includes('custom_objects') && line.includes('relu'))
                .split('\'')[1];

            // Check that it has a 0 (from it's alpha arg)
            assert(custom_relu.includes('0'));
        });
    });
});
