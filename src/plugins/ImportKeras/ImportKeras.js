/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Tue Sep 10 2019 15:28:36 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'deepforge-keras/JSONModelMaps',
    'deepforge-keras/json-model-parser'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    ModelMaps,
    JSONLayerParser
) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);


    /**
     * Initializes a new instance of ImportKeras.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin ImportKeras.
     * @constructor
     */
    var ImportKeras = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    ImportKeras.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    ImportKeras.prototype = Object.create(PluginBase.prototype);
    ImportKeras.prototype.constructor = ImportKeras;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    ImportKeras.prototype.main = function (callback) {
        let srcJsonHash = this.getCurrentConfig().srcModel;
        if (!srcJsonHash) {
            return callback(new Error('Keras Json Not Provided'), this.result);
        }

        this.archName = this.getCurrentConfig().archName;
        return this.blobClient.getMetadata(srcJsonHash)
            .then(metadata => {
                this.archName = this.archName ? this.archName : metadata.name.replace('.json', '');
                this.logger.debug(`The new architecture added will be named ${this.archName}`);
                return this.blobClient.getObjectAsJSON(srcJsonHash);
            })
            .then((modelJson) => {
                this.modelInfo = JSONLayerParser.flatten(modelJson).config;
a
                return this.addNewArchitecture()
                    .then(() => this.addLayers())
                    .then(() => this.addConnections()
                        .then(() => this.save('Completed Import Model'))
                        .then(()=> {
                            this.result.setSuccess(true);
                            callback(null, this.result);
                        })
                        .catch((err) => {
                            callback(err, this.result);
                        }));
            })
            .catch((err) => {
                this.logger.debug(`There is something wrong with Uploaded file.`);
                callback(err, this.result);
            });
    };

    ImportKeras.prototype.addNewArchitecture = function () {
        // Add Architecture
        this.importedArch = this.core.createNode({
            parent: this.activeNode,
            base: this.META.Architecture
        });
        const uniqueName = this.archName;
        this.core.setAttribute(this.importedArch, 'name', uniqueName);

        this.logger.debug(`Added ${uniqueName} as a new architecture.`);
        return Promise.resolve();
    };

    // This should add layers. constraints, initializers, regularizers as well as activations to the layer.
    ImportKeras.prototype.addLayers = function () {
        let layers = this.modelInfo.layers;
        let layerToCreate = null;
        this.layerInfo = {};
        layers.forEach((layer, index, records) => {
            layerToCreate = this._mapClassName(layer.class_name);
            let layerNode = this.core.createNode({
                parent: this.importedArch,
                base: this.META[layerToCreate]
            });
            this.logger.debug(`Added ${layerToCreate}\
            to ${this.core.getAttribute(this.importedArch, 'name')}`);

            // Add all attributes, from the model JSON, as well as from the layers schema
            this._addLayerAttributes(layerNode, layer);
            this._addConfigurableNodes(layerNode, layer);
        });
    };

    // All the attributes, which do not require a separate node to be created
    // 1. First find the validAttributeNames for the layer
    // 2. If the name is in layer, set it.
    // 3. If the name is in layer.config, set it.
    // 4. Finally, check the layers schema for remaining attributes.
    ImportKeras.prototype._addLayerAttributes = function (layerNode, attrObj) {
        let config = attrObj.config;
        let validAttributeNamesForThisLayer = this.core.getValidAttributeNames(layerNode);
        let configKeys = Object.keys(config);
        let remainingKeys = Object.keys(attrObj)
            .filter(value => value !== 'config');

        validAttributeNamesForThisLayer.forEach((attribute) => {
            if (remainingKeys.indexOf(this._mapArgName(attribute)) > -1) {
                this.core.setAttribute(layerNode, attribute, this._Stringify(attrObj[this._mapArgName(attribute)]));
                this.logger.debug(`Set ${attribute} for ${this.core.getGuid(layerNode)}` +
                    ` to ${this.core.getAttribute(layerNode, attribute)}`);
            } else if (configKeys.indexOf(this._mapArgName(attribute)) > -1) {
                this.core.setAttribute(layerNode, attribute, this._Stringify(config[this._mapArgName(attribute)]));
                this.logger.debug(`Set ${attribute} for ${this.core.getGuid(layerNode)}` +
                    ` to ${this.core.getAttribute(layerNode, attribute)}`);

            }
        });
        let layerName = this.core.getAttribute(layerNode, 'name');
        this.layerInfo[layerName] = layerNode;

    };

    ImportKeras.prototype._addConfigurableNodes = function (layerNode, layerConfig) {
        let allPointerNames = this.core.getValidPointerNames(layerNode);
        let config = layerConfig.config;
        if (allPointerNames.length > 0) {
            this.logger.debug(`Layer ${this.core.getAttribute(layerNode, 'name')}` +
                ` has following configurable attributes ${allPointerNames.join(", ")}`);
            allPointerNames.forEach((pointer) => {
                // This case, there is no extra config for this attribute

                if (config[pointer] && typeof config[pointer] === 'string') {
                    let configurableNode = this.core.createNode({
                        parent: layerNode,
                        base: this.META[config[pointer]]
                    });
                    // This will set the necessary pointers.
                    this.core.setPointer(layerNode, pointer, configurableNode);
                    this.logger.debug(`Added ${this.core.getAttribute(configurableNode, 'name')}`
                        + ` as ${pointer} to the layer `
                        + `${this.core.getAttribute(layerNode, 'name')}`);
                }
                // The configuration will exist but inside the object.
                else {
                    if (!config[pointer]) {
                    } else {
                        let pluggableNode = this.core.createNode({
                            parent: layerNode,
                            base: this.META[config[pointer].class_name]
                        });
                        this.logger.debug(`Added ${this.core.getAttribute(pluggableNode, 'name')} as ${pointer} to the layer ` +
                            `${this.core.getAttribute(layerNode, 'name')}`);
                        let validArgumentsForThisNode = this.core.getValidAttributeNames(pluggableNode);
                        let configForAddedNode = config[pointer].config;
                        if (validArgumentsForThisNode && configForAddedNode) {
                            validArgumentsForThisNode.forEach((arg) => {
                                if (configForAddedNode[arg]) {
                                    this.core.setAttribute(pluggableNode, arg, this._Stringify(configForAddedNode[arg]));
                                }
                            });
                        }
                    }
                }
            });
        }
    };

    // This method is used to convert javascript arrays to a tuple/ list in string Representation.
    ImportKeras.prototype._Stringify = function (obj) {
        if (obj instanceof Array) {
            return '[' + obj.map((val) => {
                if (val) {
                    return val;
                } else {
                    return "None";
                }
            }).join(', ') + ']';
        } else {
            return obj;
        }
    };

    // This method is used to convert various classes from the keras JSON to deepforge meta Nodes
    ImportKeras.prototype._mapClassName = function (orgName) {
        let classMap = ModelMaps.CLASS_MAP;
        if (Object.keys(classMap).indexOf(orgName) > -1) {
            return classMap[orgName];
        } else {
            return orgName;
        }
    };

    ImportKeras.prototype._mapArgName = function (orgName) {
        let argMap = ModelMaps.ARGUMENTS_MAP;
        if (Object.keys(argMap).indexOf(orgName) > -1) {
            return argMap[orgName];
        } else {
            return orgName;
        }
    };
    /**********************The functions below Add Connections between the Layers**************/
    ImportKeras.prototype.addConnections = function () {
        // this._findNodeByName();
        let layers = this.modelInfo.layers;
        let layerInputConnections = {};
        let layerOutputConnections = {};
        let connections = null;
        layers.forEach((layer) => {
            layerInputConnections[layer.name] = [];
            layerOutputConnections[layer.name] = [];
        });

        layers.forEach((layer) => {
            if (layer.inbound_nodes.length > 0) {
                connections = layer.inbound_nodes;
                connections.forEach((connection) => {

                        if (this._layerNameExists(connection)) {
                            layerInputConnections[layer.name].push(connection);
                            layerOutputConnections[connection].push(layer.name);
                    }
                });

            }
        });

        return this._updateConnections(layerInputConnections, layerOutputConnections);

    };


    ImportKeras.prototype._layerNameExists = function (layerName) {
        let allLayerNames = this.modelInfo.layers.map((layer) => {
            return layer.name;
        });

        return allLayerNames.indexOf(layerName) > -1;
    };

    ImportKeras.prototype._updateConnections = function (inputs, outputs) {
        let allLayerNames = Object.keys(inputs);
        return Promise.all(allLayerNames.map((layerName) => {
            let dstLayer = this.layerInfo[layerName];
            let srcs = inputs[layerName];
            if (srcs.length > 0) {
                return Promise.all(srcs.map((src, index, records) => {
                    return this._connectLayers(this.layerInfo[src], dstLayer, index);
                }));
            }

        }));
    };

    ImportKeras.prototype._connectLayers = async function (srcLayer, dstLayer, index) {

        let srcPort = await this.core.loadMembers(srcLayer, 'outputs');
        let dstPort = await this.core.loadMembers(dstLayer, 'inputs');
        if (dstPort && srcPort) {
            this.core.addMember(dstPort[0], 'source', srcPort[0]);
            this.core.setMemberRegistry(dstPort[0],
                'source',
                this.core.getPath(srcPort[0]),
                'position', {x: 100, y: 100});
            this.core.setMemberAttribute(dstPort[0], 'source',
                this.core.getPath(srcPort[0]),
                'index', index);
            this.logger.debug(`Connected ${this.core.getAttribute(srcLayer, 'name')} ` +
                `with ${this.core.getAttribute(dstLayer, 'name')} as input ${index}`);
            return Promise.resolve('Done');
        }
    };

    return ImportKeras;
});
